# Let there be light 


In this chapter we will learn how to add light to our 3D game engine. We will not implement a physical perfect light model because, taking aside the complexity, it would require a tremendous amount of computer recourses, instead we will implement an approximation which will provide decent results. We will use an algorithm named Phong shading  (developed by Bui Tuong Phong). Another important thing to point is that we will only model lights but we won’t me model the shadows that should be generated by those lights (this will be done in another chapter). 

Before we start, let us define some light types:
* **Point light**: This type of light models a light source that’s emitted uniformly form a point in space in all directions.
* Spot light: This type of light models a light source that’s emitted from a point in space, but instead of emitting in all directions is restricted to a cone.
* **Directional light**: This type for light models the light that we receive from the sun, all the objects in the 3D the space are  hit by parallel ray lights coming from a specific direction. No matter if the object is close or of far all the right lights impact the objects with the same angle.
* **Ambient light**: This type of light comes from everywhere in the space and illuminates all the objects in the same way.
 
![Light types](light_types.png)

Thus, to model light we need to take into consideration the type of light plus, its position and some other parameters like its colour. Of course, the light hits objects and the way those objects absorb and reflect light is also important.

The Phong shading algorithm will the effects of light for each point in our model, that is for every vertex. This is why it’s called a local illumination simulation, this is the reason which this algorithm will not calculate shadows, it will just calculate the light tp be applied to every vertex without taking into consideration if the vertex is behind an objects that blocks the light. We will overcome this in later chapters. But, because of that is a very simple and fast algorithm that provides very goof effects. We will use here a simplified version that does not take into account materials deeply.
The Pong algorithm considers three components for lighting:
	Ambient light: models light that comes from everywhere, this will serve us to illuminate (with the require intensity) the areas that are not hit by any light, it’s like a background light.
	Diffuse reflectance: It takes into consideration that surfaces that are facing the light source are brighter.
	Specular reflectance: models how light reflects in polished or metallic surfaces

At the end what we want to obtain is a factor that, multiplied by our model colour, will get that colour brighter or darker depending on the light. Let’s name our components as $$A$$ for ambient, $$D$$ for diffuse and $$S$$ for specular. That factor will be the addition of those components:

$$L = A + D + S$$

In fact, those components are indeed colours, that is the colour components that each light component contributes to. Light will not only provide a degree of intensity but it can modifiy the colour of model.  In our fragment shader we just need to multiply that light colour by the original fragment colour (obtained from a texture or a base colour). So the final colour will be: $$L * basecolour$$.

Let’s view the first component, the ambient light component it’s just a constant factor that will make all of our objects brighter or darker. We can use to simulate light for a specific period of time (dawn, dusk, et.c) also it can be used to add some light to points that are not hit directly by ray lights but could be lighted by  indirect light (caused by reflections) in an easy way.

Ambient light is the easiest component to calculate, we just need to pass a colour, since it will be multiplied by our base colour it just modulates that base colour. Imagine that we have determined that a colour for a fragment is $$(1.0, 0.0, 0.0)$$, that is red colour. Without ambient light it will be dissplayed as a fully red fragment. If we set ambient light to $$(0.5, 0.5, 0.5)$$ the final colour will be $$(0.5, 0, 0)$$, that is a darker version of red. This light will darken all the fragments in the same way. Besides that it can add some colour if the RGB components are not the same, so we just need a vector to modulate ambient light intensity and colour.

Let’s talk now about diffuse reflectance. It models the fact that surfaces which face in a perpendicular way to the light source look brighter than surfaces where light is received in a  more indirect angle. Those objects receive more light, the light density (let me call it this way) is higher.

![Diffuse Light](diffuse_light.png) 

But, how do we calculate this ? Do you remember from previous chapter that we introduced the normal concept ? The normal was the vector perpendicular to a surface that had length equal to one. So, Let’s draw the normals for  three points in the previous figure, as you can see, the normal for each point will be the vector perpendicular to the tangent plane for each point. Instead of drawing rays coming from the source of light we will draw vectors from each point to the point of light (that is, in the opposite direction).

![Normals and light direction](diffuse_light_normals.png) 

As you can see, the normal associated to $$P1$$, named $$N1$$, is parallel to the vector that points to the light source,  which models the opposite of the light ray ($$N1$$ has been sketched displaced so you can see it, but it’s equivalent mathematically). $$P1$$ has an angle equal to $$0$$ with the vector that points to the light source. It’s surface is perpendicullar to the light source and $$P1$$ would be the brighter point.

The normal associated to $$P2$$, named $$N2$$, has an angle of around 30 degrees with the vector that points the light source, so it should be darker tan $$P1$$. Finally, the normal associated to $$P3$$, named $$N3$$, is also parrallel to the vector that points to the light source but both vectors are in the opposite direction. $$P3$$ has an angle of 360 degrees with the vector that points the light source, and should not get any light at all.

So it seems that we have a good approach to determine the light intensity that gets to a point and it’s related to the  angle that forms the normal with a vector that points to the light source. How can we calculate this ?

There’s a mathematical operation that we can use and it’s called dot product. This operation takes two vectors and produces a number (a scalar), that is positive if the angle between them is small and negative if the angle between them is wide. If both vectors are normalized, that is the both have a length equal to one, the dot product will be between $$-1$$ and $$1$$. The dot product will be one if both vectors look in the same direction (angle $$0$$), it will be $$0$$ if both vectors form a square angle and will be $$-1$$ if both vectors face opposite direction. 

Let’s define two vectors, v1 and v2, and let α be the angle between them. The dot product is defined by the following formula.

![Dot product](dot_product.png) 

If both vectors are normalize, their length, their module will be equal to one, so the dot product is equal to the cosine if the angle between them. We will use that operation to calculate the diffuse reflectance component.

So we need to calculate the vector that points to the source of light. How we do this ? We have the position of each point (the vertex position) and we have the position of the light source. First of all, both coordinates must be in the same coordinate space. To simplify, let’s assume that they are both in world coordinate space, then those positions are the coordinates of the vectors that point to the vertex position ($$VP$$) and to the light source ($$VS$$), as shown in the next figure.

![Difffuse Light calculation I](diffuse_calc_i.png) 

If we substract $$V$$S from $$VP$$ we get the vector that we are looking for which it’s called $$L$$.
 
Now we can do the dot product between the vector that points to the light source and the normal, that product is called the Lambert term, due to Johann Lambert which was the first to propose that relation to model the brightness of a surface.

Let’s summarize how we can calculate it, we define the following variables:
* $$vPos$$: Position of our vertex in model view space coordinates.
* $$lPos$$: Position of the light in view space coordinates.
* $$intensity$$: Intensity of the light (from 0 to 1).
* $$lColour$$: Colour of the light.
* $$normal$$: The vertex normal.
* 
First we need to calculate the vector that points to the light source from current position: $$to_light_direction = lPos - vPos$$. The result needs to be normalized

Then we need to calculate the diffuse factor (an scalar): $$diffuseFactor = normal * to_light_direction$$. It’s calculated as dot product between two vectors, since we want it to be between $$-1$$ and $$1$$ both vectors need to be normalized. Colours need to be between $$0$$ and $$1$$ so if a value it’s lower than $$0$$ we will set it to 0.

Finally we just need to modulate the light colour by the diffuse factor and the light intensity:

$$colour = lColour * diffuseFactor * intensit$$y

Let’s view now the specular component, but first  we need to examine how light is reflected. When light hits a surface some part of it is absorbed and the other part is reflected, if you remember from your physics class, reflection is when light bounces off an object.
 
![Light reflection](light_reflection.png)

Of course, surfaces are not totally polished, and if you look at closer distance you will see a lot of imperfections that. Besides that, you have many ray lights (photons in fact), that impact that surface, and that get reflected in a wide range of angles. You what we see is like a beam of light being reflected from the surface. That is, light is diffused when impact a surface, and that’s the disuse component that we have been talking about previously.
 
![Surface](surface.png)
 
But when light impacts a polished surface, for instance a metal, the light suffers from lower diffusion and most of it gets reflected in the opposite direction as it hit that surface.

![Polished surface](polished_surface.png) 

This is what the specular component models, and it depends on the material characteristics. Regarding specular reflectance, it’s important to note that  the reflected light will only be visible if the camera is in a proper position, that is, is in the area of where the reflected light is emitted.

![Specular lightning](specular_lightining.png) 

Once the mechanism that’s behind sepecular reflection has been explained we are ready to calculate that component. First we need a vector that points from the light source to the vertex point.  When we were calculating the difusse component we calculated just the opposite, a vector that points to the light source. $$toLightDirection$$, so let’s  calculate it as $$fromLightDirection =–toLightDirection$$.

Then we need to calculate the reflected light that results from the impact of the $$fromLightDirection$$ into the surface by taking into consideration its normal. There’s a GLSL function that does that named reflect. So, $$reflectedLight = reflect(fromLightSource, normal)$$.

We also need a vector that points to the camera, let’s name it $$cameraDirection$$, and it will be calculated as the difference between the camera position and the vertex position: $$cameraDirection = cameraPos – vPos$$. The camera position vector and the vertex position need to be in the same coordinate system and the resulting vector needs to be normalized. The following figure sketches the main components we have calculated up to now.

![Specular lightning calculation](specular_lightining_calc.png)
 
Now we need to calculate the light intensity that we see which we will call $$specularFactor$$, this component will be higher if the $$cameraDirection$$ and the $$reflectedLight$$ vectors are parallel and point in the same direction and will take its lower value if they point in opposite directions. In order to calculate this the dot product comes to the rescue again. So $$specularFactor = cameraDirection . reflectedLight$$. We only want this value to be between $$0$$ and $$1$$ so if it’s lower than $$0$$ it will be set to 0.

We also need to take into consideration that this light must be more intense if the camera is pointing to the reflected light done by  powering the $$specularFactor$$ to a parameter named $$specularPower$$.

$$specularFactor = specularFactor\pow(specularPower)$$.

Finally we need to model the reflectivity of the material, which will also modulate the intensity if the light reflected, this will be done with another parameter named reflectance. So the colour component of the specular component will be: $$lColour * reflectance * specularFactor * intensity$$.

We now know how to calculate the three components that will serve us to model a point light with an ambient light. But our light model is still not complete, the light that an object reflects is independent of the distance that the light is, we need to simulate light attenuation. 
